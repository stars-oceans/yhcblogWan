import{_ as s,c as i,o as a,V as n}from"./chunks/framework.WW8f2_VW.js";const g=JSON.parse('{"title":"XHR 和 Fetch 的区别","description":"XHR 和 Fetch 的区别","frontmatter":{"post":true,"title":"XHR 和 Fetch 的区别","date":"2023-12-26T00:00:00.000Z","cover":"https://i.postimg.cc/NF9NwB5y/2jki2zjyjs6a.png","coveross":"https://i.postimg.cc/NF9NwB5y/2jki2zjyjs6a.png","categories":["JavaScript"],"tags":["JS","请求"],"description":"XHR 和 Fetch 的区别"},"headers":[],"relativePath":"posts/2023/12/16.你知道 XHR 和 Fetch 的区别吗？.md","filePath":"posts/2023/12/16.你知道 XHR 和 Fetch 的区别吗？.md"}'),t={name:"posts/2023/12/16.你知道 XHR 和 Fetch 的区别吗？.md"},e=n(`<h1 id="你知道-xhr-和-fetch-的区别吗" tabindex="-1">你知道 XHR 和 Fetch 的区别吗？ <a class="header-anchor" href="#你知道-xhr-和-fetch-的区别吗" aria-label="Permalink to &quot;你知道 XHR 和 Fetch 的区别吗？&quot;">​</a></h1><p>现如今，网站开发普遍采用前后端分离的模式，数据交互成为了不可或缺的关键环节。在这个过程中，<code>XHR</code> 和 <code>Fetch API</code> 是两种最常见的方法，用于从 Web 服务器获取数据。<code>XHR</code> 是一种传统的数据请求方式，而 <code>Fetch API</code> 则代表了现代 Web 开发的新兴标准。接下来，我们将一同深入学习它们的使用方法和适用场景。</p><h2 id="xmlhttprequest" tabindex="-1">XMLHttpRequest <a class="header-anchor" href="#xmlhttprequest" aria-label="Permalink to &quot;XMLHttpRequest&quot;">​</a></h2><p><strong>XMLHttpRequest</strong>**[1]**，通常简称为 XHR。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。XMLHttpRequest 在 AJAX 编程中（比如 jquery）被大量使用。</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AJAX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ：异步 JavaScript 和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">XML</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">。许多人容易把它和 jq 的 ajax 混淆。它是一个技术统称，本身不是一种技术。</span></span></code></pre></div><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ol><li><strong>异步请求</strong>：XHR 允许进行异步请求，它可以在后台执行，而不会阻止页面的其他操作。</li><li><strong>支持跨域请求</strong>：通过服务器端设置允许跨域请求，从不同域的服务器获取数据。</li><li><strong>事件驱动</strong>：提供了 <code>onload</code>、<code>onerror</code>、<code>onprogress</code> 等一系列事件来监听请求的状态变化。</li><li><strong>灵活性</strong>：提供了对请求头、响应头以及请求方法的完全控制，使其非常灵活。</li></ol><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p>XHR 的工作原理主要为：</p><ol><li>创建 XHR 对象实例：通过<code>new XMLHttpRequest()</code>创建一个 XHR 对象。</li><li>配置请求：使用<code>open()</code>方法设置请求方法（GET、POST 等）、URL，以及是否要异步执行请求。</li><li>设置回调函数：设置事件处理程序来处理请求完成、成功、失败等不同的状态。</li><li>发起请求：使用<code>send()</code>方法发送请求。</li><li>处理响应：在事件处理程序中处理响应数据，通常使用<code>responseText</code>或<code>responseXML</code>来访问响应内容。</li></ol><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个新的XHR对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> xhr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XMLHttpRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;GET&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.baidu.com/test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置响应处理函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (xhr.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 请求成功</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> responseData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xhr.responseText;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;成功获取数据：&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, responseData);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 请求失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;请求失败，状态码：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xhr.status);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发起请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>XHR 的响应处理通常在<code>onreadystatechange</code>事件处理程序中完成。在上面的例子中，我们等待 XHR 对象的状态变为 <code>4</code>（表示请求完成）并且 HTTP 状态码为 <code>200</code>（表示成功响应）时，解析响应数据。</p><h2 id="fetch-api" tabindex="-1">Fetch API <a class="header-anchor" href="#fetch-api" aria-label="Permalink to &quot;Fetch API&quot;">​</a></h2><p><strong>Fetch</strong> 是一种现代的数据网络请求 API，它旨在解决 XHR 的一些问题，提供了更强大、更灵活的方式来处理 HTTP 请求。可以理解为 XMLHttpRequest 的升级版。</p><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ol><li><strong>Promise 风格</strong>：Fetch API 使用 <code>Promise</code> 对象来处理异步请求，使代码更具可读性和可维护性。</li><li><strong>更简单的语法</strong>：相较于 XHR，Fetch API 的语法更加简单明了，通常只需要几行代码来完成请求。</li><li><strong>默认不接受跨域请求</strong>：为了安全性，Fetch API 默认不接受跨域请求，但可以通过 <code>CORS</code>（跨域资源共享）来进行配置。</li><li><strong>更现代的架构</strong>：Fetch API 是建立在 <code>Promise</code> 和 <code>Stream</code> 之上的，支持更灵活的数据处理和流式传输。</li></ol><h3 id="工作原理-1" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理-1" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p>Fetch 的工作原理主要为：</p><ol><li>使用<code>fetch()</code>函数创建请求：传入要请求的 URL，以及可选的配置参数，例如请求方法、请求头等。</li><li>处理响应：<code>fetch()</code>返回一个 Promise，您可以使用<code>.then()</code>链式调用来处理响应数据，例如使用<code>.json()</code>方法解析 JSON 数据或<code>.text()</code>方法获取文本数据。</li><li>错误处理：您可以使用<code>.catch()</code>方法来捕获任何请求或响应的错误。</li><li>使用<code>async/await</code>：如果需要，您还可以使用<code>async/await</code>来更清晰地处理异步操作。</li></ol><p>Fetch API 的特性和简单的语法使它在许多前端项目中成为首选工具。然而，它也有一些限制，例如不支持同步请求，因此需要谨慎使用。</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.baidu.com/test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">response.ok) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;请求失败，状态码：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.status);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 请求成功，处理响应数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;成功获取数据：&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 请求失败，处理错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre></div><h2 id="xhr-和-fetch-的对比" tabindex="-1">XHR 和 Fetch 的对比 <a class="header-anchor" href="#xhr-和-fetch-的对比" aria-label="Permalink to &quot;XHR 和 Fetch 的对比&quot;">​</a></h2><p>XHR 和 Fetch 都用于进行 HTTP 请求，但它们之间存在一些关键区别：</p><ul><li><strong>语法：</strong> Fetch 使用 Promise，更直观和易于理解。</li><li><strong>跨域请求：</strong> Fetch 在跨域请求方面更灵活，支持 CORS。</li><li><strong>流式传输：</strong> Fetch 支持可读流，适用于大文件下载。</li><li><strong>维护性：</strong> Fetch 更容易维护和扩展。</li></ul><h2 id="常用库和插件" tabindex="-1">常用库和插件 <a class="header-anchor" href="#常用库和插件" aria-label="Permalink to &quot;常用库和插件&quot;">​</a></h2><h3 id="基于-xhr-封装的库" tabindex="-1">基于 XHR 封装的库 <a class="header-anchor" href="#基于-xhr-封装的库" aria-label="Permalink to &quot;基于 XHR 封装的库&quot;">​</a></h3><ul><li>jquery：一个 JavaScript 库，提供了用于处理 DOM 操作、事件处理和 XHR 请求的便捷方法。</li><li><strong>axios</strong>：一个流行的 HTTP 请求库，基于 XHR 开发，支持浏览器和 Node.js。</li></ul><h3 id="基于-fetch-封装的库" tabindex="-1">基于 fetch 封装的库 <a class="header-anchor" href="#基于-fetch-封装的库" aria-label="Permalink to &quot;基于 fetch 封装的库&quot;">​</a></h3><ul><li><strong>redaxios</strong>：它具有与 axios 类似的 API，但更轻量级且适用于现代 Web 开发。</li><li><strong>umi-request</strong>：由 Umi 框架维护的网络请求库，提供了强大的拦截器、中间件和数据转换功能。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>XMLHttpRequest (XHR) 和 Fetch API 都是前端开发中用于进行数据请求的有力工具。XHR 在传统项目中仍然有用，而 Fetch API 则在现代 Web 开发中越来越流行。具体选择哪个工具取决于项目的需求和开发团队的偏好，希望本文对你有帮助！</p>`,31),h=[e];function l(p,k,r,o,d,c){return a(),i("div",null,h)}const y=s(t,[["render",l]]);export{g as __pageData,y as default};
