import{_ as s,c as i,o as a,V as e}from"./chunks/framework.WW8f2_VW.js";const c=JSON.parse('{"title":"vue3——onBeforeRouteLeave","description":"vue3——onBeforeRouteLeave","frontmatter":{"post":true,"title":"vue3——onBeforeRouteLeave","date":"2024-01-26T00:00:00.000Z","cover":"https://i.postimg.cc/hvbmkVps/Vue-for-React-Devs-Similarities.jpg","coveross":"https://i.postimg.cc/hvbmkVps/Vue-for-React-Devs-Similarities.jpg","categories":["Vue"],"tags":["路由","vue3"],"description":"vue3——onBeforeRouteLeave"},"headers":[],"relativePath":"posts/2024/01/11.Vue3——onBeforeRouteLeave.md","filePath":"posts/2024/01/11.Vue3——onBeforeRouteLeave.md"}'),t={name:"posts/2024/01/11.Vue3——onBeforeRouteLeave.md"},n=e(`<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><blockquote><p>最近做了个h5项目，要求在页面返回到首页时（因项目需求，首页是一个中转页面，不适合单独展现），直接关闭窗口，回到公众号。接到这个需求时第一反应是中转页跳转时直接用router.replace不就行了吗，但经测试发现replace跳转在微信中并不起作用，中转页面并没有被替换掉，后来通过onBeforeRouteLeave方法检测页面才得以解决。下面我们来看下onBeforeRouteLeave方法的使用。</p></blockquote><h3 id="onbeforerouteleave" tabindex="-1">onBeforeRouteLeave <a class="header-anchor" href="#onbeforerouteleave" aria-label="Permalink to &quot;onBeforeRouteLeave&quot;">​</a></h3><blockquote><p>vue3 router中新增的onBeforeRouteLeave方法表示添加一个导航守卫，此方法会在组件将要离开的时候触发，类似于以前的beforeRouteLeave，但onBeforeRouteLeave可以在任何组件中使用，当组件被卸载的时候，导航守卫也将被移除。当我们使用router执行跳转或返回的时候，就会触发onBeforeRouteLeave方法，这时候就可以处理一些逻辑。</p></blockquote><h2 id="比如当我们某个值没有时" tabindex="-1">比如当我们某个值没有时 <a class="header-anchor" href="#比如当我们某个值没有时" aria-label="Permalink to &quot;比如当我们某个值没有时&quot;">​</a></h2><h3 id="这样我们的路由当这个田间不支持时就不能跳转路由" tabindex="-1">这样我们的路由当这个田间不支持时就不能跳转路由 <a class="header-anchor" href="#这样我们的路由当这个田间不支持时就不能跳转路由" aria-label="Permalink to &quot;这样我们的路由当这个田间不支持时就不能跳转路由&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onBeforeRouteLeave</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (patientId.value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h5 id="在开头中我们说的场景中-当从a页面返回到首页时-返回前会触发a页面当中写的onbeforerouteleave方法-这时候我们可以返回false来阻止返回并关闭窗口-去往别的页面-如下代码" tabindex="-1">在开头中我们说的场景中，当从A页面返回到首页时，返回前会触发A页面当中写的onBeforeRouteLeave方法，这时候我们可以返回false来阻止返回并关闭窗口， <strong>去往别的页面</strong> 如下代码： <a class="header-anchor" href="#在开头中我们说的场景中-当从a页面返回到首页时-返回前会触发a页面当中写的onbeforerouteleave方法-这时候我们可以返回false来阻止返回并关闭窗口-去往别的页面-如下代码" aria-label="Permalink to &quot;在开头中我们说的场景中，当从A页面返回到首页时，返回前会触发A页面当中写的onBeforeRouteLeave方法，这时候我们可以返回false来阻止返回并关闭窗口， **去往别的页面** 如下代码：&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onBeforeRouteLeave</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><blockquote><p>上述代码中会加一个to.path是否是首页index的判断，因为onBeforeRouteLeave方法在页面正常跳转的时候也会触发，所以要判断下只有在返回首页的时候才进行阻止。 如果我们只有一个页面需要返回到首页时特殊处理，那么上述方法就非常好用，但如果是多个页面呢，每个页面中都加入onBeforeRouteLeave方法来判断就比较麻烦了，这时候我们就可以在router中的beforeEach中进行处理。如下：</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(to.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/index&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pages.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(from.path)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><blockquote><p>如上代码，我们可以维护一个需要这种处理的页面列表，然后在beforeEach中判断一下如果是从这些页面返回到的首页，就直接关闭窗口即可。 或者，因为我们确定首页中转页只有从入口进入，其余到首页都是返回的情况下，就可以通过判断from.path是不是空路由/，来过滤掉入口进入的情况，其余情况就直接关闭即可，如下：</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(to.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/index&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from.path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div>`,13),h=[n];function l(p,k,r,o,E,d){return a(),i("div",null,h)}const u=s(t,[["render",l]]);export{c as __pageData,u as default};
